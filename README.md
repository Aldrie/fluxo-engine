# **@fluxo-engine**
*A flexible, modular, fast, and lightweight workflow engine.*  

Fluxo is a powerful framework designed for building and executing workflows using a node-based architecture. It enables seamless process automation by connecting nodes and edges (via handles), ensuring efficiency, scalability, and adaptability.

## **Features**  
üß© **Modular Execution** ‚Äì Define custom executors for different node types.

üîó **Edge-Based Flow** ‚Äì Nodes are connected via handles, specifying `sourceValue` and `targetValue` for mapping inputs and outputs.

üîÑ **Loop Execution** ‚Äì Special support for loop-based nodes where all child nodes execute in a loop.

‚ö°Ô∏è **Lightweight & Fast** ‚Äì Designed for performance with minimal overhead.  

## **üì¶ Installation**  
To install Fluxo, run:

```sh
pnpm add @fluxo-engine/core
```

## **üí° Usage Examples**

### **üîß 1. Function-Based Executors** 

#### **Standard Node Execution**

```ts
import { NodeExecutor } from '@fluxo-engine/core';
import { NodeTypes } from './types';

const simpleExecutor: NodeExecutor<NodeTypes> = {
  type: NodeTypes.SIMPLE,
  async execute(input, data) {
    // Process the input and return output
    return { result: (input.num0 as number) + (input.num1 as number) };
  },
};
```

#### **Loop Execution (Special Behavior)** üîÑ

> **Note:** The `LoopExecutor` iterates over an array and executes all nodes within its loop hierarchy for each iteration.

```ts
import { LoopNodeExecutor } from '@fluxo-engine/core';
import { NodeTypes } from './types';

const loopExecutor: LoopNodeExecutor<NodeTypes> = {
  type: NodeTypes.LOOP,
  isLoopExecutor: true,
  async getArray(input, data, iteration) {
    // Generate an array of outputs to iterate over
    return Array.from({ length: input.count as number }, (_, i) => ({ index: i }));
  },
};
```

### **üèóÔ∏è 2. Class-Based Executors** 

You can also define executors as classes by implementing the respective interfaces.

#### **Standard Node Executor with a Class**

```ts
import { NodeExecutor } from '@fluxo-engine/core';
import { NodeTypes } from './types';

class SimpleNodeExecutor implements NodeExecutor<NodeTypes> {
  type = NodeTypes.SIMPLE;

  async execute(input: { num0: number; num1: number }, data: Record<string, unknown>) {
    // Execute node logic and return output
    return { result: input.num0 + input.num1 };
  }
}

// Instantiate and export the executor
export const simpleNodeExecutor = new SimpleNodeExecutor();
```

#### **Loop Executor with a Class**

```ts
import { LoopNodeExecutor } from '@fluxo-engine/core';
import { NodeTypes } from './types';

class SimpleLoopExecutor implements LoopNodeExecutor<NodeTypes> {
  type = NodeTypes.LOOP;
  isLoopExecutor = true;

  async getArray(
    input: { count: number },
    data: Record<string, unknown>,
    iteration?: number
  ) {
    // Generate an array to loop over; each iteration returns an object with an index
    return Array.from({ length: input.count }, (_, i) => ({ index: i }));
  }
}

// Instantiate and export the executor
export const simpleLoopExecutor = new SimpleLoopExecutor();
```

### **üîÑ‚û°Ô∏è 3. Defining and Executing a Flow** 

A **flow** consists of nodes and edges defining the execution order. **Edges** now include `sourceValue` and `targetValue` (handles) to map outputs of one node to inputs of another.

#### **Example Flow:**

<img src="./docs/example-flow.svg" alt="Example Flow" />

#### **Edge Mapping:**  
The edge will connect the `result` handle of the "sum" node to the `number` handle of the "number_to_string" node:

```ts
import { getFlowHandler } from '@fluxo-engine/core';
import { sumExecutor } from './SumExecutor'; // class-based
import { numberToStringExecutor } from './NumberToStringExecutor'; // class-based

enum NodeTypes {
  SUM = 'sum',
  NUMBER_TO_STRING = 'number_to_string',
};

// Define flow handler with your executors (you can mix function-based and class-based)
const flowHandler = getFlowHandler({
  executors: [sumExecutor, numberToStringExecutor],
  enableLogger: true,
});

// Define nodes
const nodes = [
  {
    id: 'sum',
    type: NodeTypes.SUM,
    input: { num0: 5, num1: 7 },
    output: {},
  },
  {
    id: 'number_to_string',
    type: NodeTypes.NUMBER_TO_STRING,
    input: { number: null }, // value will be set via edge mapping
    output: {},
  },
];

// Define edges with handles mapping
const edges = [
  {
    source: 'sum',
    target: 'number_to_string',
    sourceValue: 'result',   // the output handle from the "sum" node
    targetValue: 'number',   // the input handle of the "number_to_string" node
  },
];

// Execute the flow
await flowHandler.execute({ nodes, edges });
```

## **üîÑ‚ú® Special Behavior of LoopExecutor**

The **Loop Executor** (`isLoopExecutor: true`) has a unique execution pattern:
- **Iteration:** It iterates over an array generated by the `getArray` method.
- **Nested Execution:** All nodes within the loop's hierarchy are executed for each iteration.
- **Data Propagation:** Enables repetitive or batch processing seamlessly within your workflow.

## **üöÄ Why Use Fluxo?** 

- **Flexible:** Easily define any node behavior via custom executors.  
- **Efficient:** Minimal overhead ensures fast execution of workflows.  
- **Scalable:** Capable of handling both simple and complex workflow scenarios.  
- **Precise Data Mapping:** Use handles (`sourceValue` and `targetValue`) to clearly define how outputs feed into inputs across nodes.

## Roadmap

- [ ] **üìÑ Enhanced Documentation**  
  Improve the documentation with more detailed guides, examples, and installation instructions.

- [ ] **ü¶Ä Rust Integration for Better Performance**  
  Explore and integrate Rust modules to optimize critical parts of the engine and boost performance.

<img src="https://media.tenor.com/sbfBfp3FeY8AAAAj/oia-uia.gif" width="100" alt="Fluxo Animation"/>
